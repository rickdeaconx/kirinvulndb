from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum

from app.models.vulnerability import SeverityEnum, PatchStatusEnum, AttackVectorEnum


class VulnerabilityBase(BaseModel):
    vulnerability_id: str = Field(..., description="Unique vulnerability identifier")
    cve_id: Optional[str] = Field(None, description="CVE identifier if available")
    title: str = Field(..., max_length=500, description="Vulnerability title")
    description: str = Field(..., description="Detailed vulnerability description")
    severity: SeverityEnum = Field(..., description="Vulnerability severity level")
    cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0, description="CVSS base score")
    cvss_vector: Optional[str] = Field(None, description="CVSS vector string")


class VulnerabilityCreate(VulnerabilityBase):
    discovery_date: datetime = Field(..., description="Date vulnerability was discovered")
    public_disclosure: Optional[datetime] = Field(None, description="Public disclosure date")
    attack_vectors: List[AttackVectorEnum] = Field(default=[], description="Attack vectors")
    technical_details: Optional[str] = Field(None, description="Technical details")
    impact_assessment: Optional[str] = Field(None, description="Impact assessment")
    patch_status: PatchStatusEnum = Field(default=PatchStatusEnum.UNPATCHED)
    remediation_steps: Optional[str] = Field(None, description="Remediation steps")
    affected_versions: Optional[Dict[str, List[str]]] = Field(None, description="Affected versions by tool")
    fixed_versions: Optional[Dict[str, List[str]]] = Field(None, description="Fixed versions by tool")
    poc_available: bool = Field(default=False, description="Proof of concept available")
    exploit_in_wild: bool = Field(default=False, description="Exploit observed in the wild")
    tags: List[str] = Field(default=[], description="Vulnerability tags")
    references: List[str] = Field(default=[], description="Reference URLs")
    source: str = Field(..., description="Data source")
    confidence_score: float = Field(default=1.0, ge=0.0, le=1.0, description="Confidence score")
    affected_tools: List[str] = Field(default=[], description="List of affected AI tools")
    cwe_ids: List[str] = Field(default=[], description="CWE identifiers")
    
    @validator('references')
    def validate_references(cls, v):
        if v:
            for ref in v:
                if not ref.startswith(('http://', 'https://')):
                    raise ValueError(f"Invalid URL: {ref}")
        return v


class VulnerabilityUpdate(BaseModel):
    title: Optional[str] = Field(None, max_length=500)
    description: Optional[str] = Field(None)
    severity: Optional[SeverityEnum] = Field(None)
    cvss_score: Optional[float] = Field(None, ge=0.0, le=10.0)
    cvss_vector: Optional[str] = Field(None)
    patch_status: Optional[PatchStatusEnum] = Field(None)
    remediation_steps: Optional[str] = Field(None)
    affected_versions: Optional[Dict[str, List[str]]] = Field(None)
    fixed_versions: Optional[Dict[str, List[str]]] = Field(None)
    poc_available: Optional[bool] = Field(None)
    exploit_in_wild: Optional[bool] = Field(None)
    tags: Optional[List[str]] = Field(None)
    references: Optional[List[str]] = Field(None)
    confidence_score: Optional[float] = Field(None, ge=0.0, le=1.0)
    
    @validator('references')
    def validate_references(cls, v):
        if v:
            for ref in v:
                if not ref.startswith(('http://', 'https://')):
                    raise ValueError(f"Invalid URL: {ref}")
        return v


class VulnerabilityResponse(VulnerabilityBase):
    id: str = Field(..., description="Internal UUID")
    discovery_date: Optional[datetime] = Field(None)
    public_disclosure: Optional[datetime] = Field(None)
    first_seen_timestamp: datetime = Field(...)
    last_updated_timestamp: datetime = Field(...)
    attack_vectors: List[AttackVectorEnum] = Field(default=[])
    technical_details: Optional[str] = Field(None)
    impact_assessment: Optional[str] = Field(None)
    patch_status: PatchStatusEnum = Field(...)
    remediation_steps: Optional[str] = Field(None)
    affected_versions: Optional[Dict[str, List[str]]] = Field(None)
    fixed_versions: Optional[Dict[str, List[str]]] = Field(None)
    poc_available: bool = Field(default=False)
    exploit_in_wild: bool = Field(default=False)
    exploit_maturity: Optional[str] = Field(None)
    tags: List[str] = Field(default=[])
    references: List[str] = Field(default=[])
    source: str = Field(...)
    confidence_score: float = Field(...)
    kirin_remediation_available: bool = Field(default=False)
    kirin_policy_mappings: Optional[Dict[str, Any]] = Field(None)
    auto_remediation_possible: bool = Field(default=False)
    cwe_ids: List[str] = Field(default=[])
    owasp_category: Optional[str] = Field(None)
    mitre_techniques: List[str] = Field(default=[])
    affected_tools: List[str] = Field(default=[])
    created_at: datetime = Field(...)
    updated_at: datetime = Field(...)
    
    class Config:
        from_attributes = True


class VulnerabilityList(BaseModel):
    vulnerabilities: List[Dict[str, Any]] = Field(...)
    total: int = Field(..., description="Total number of vulnerabilities")
    limit: int = Field(..., description="Number of results returned")
    offset: int = Field(..., description="Offset used for pagination")
    
    class Config:
        from_attributes = True


class VulnerabilitySummary(BaseModel):
    """Lightweight vulnerability summary for lists and feeds"""
    id: str
    vulnerability_id: str
    title: str
    severity: SeverityEnum
    cvss_score: Optional[float]
    patch_status: PatchStatusEnum
    affected_tools: List[str]
    discovery_date: Optional[datetime]
    created_at: datetime
    
    class Config:
        from_attributes = True