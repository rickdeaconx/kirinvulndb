from sqlalchemy.orm import Session
from typing import Optional, List
from datetime import datetime
import uuid
import logging

from app.models.vulnerability import Vulnerability
from app.models.tool import AITool
from app.schemas.vulnerability import VulnerabilityCreate, VulnerabilityUpdate
from app.services.websocket_manager import websocket_manager

logger = logging.getLogger(__name__)


class VulnerabilityService:
    """Service class for vulnerability operations"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def create_vulnerability(self, vulnerability_data: VulnerabilityCreate) -> Vulnerability:
        """Create a new vulnerability"""
        
        # Check if vulnerability already exists
        existing = self.db.query(Vulnerability).filter(
            Vulnerability.vulnerability_id == vulnerability_data.vulnerability_id
        ).first()
        
        if existing:
            raise ValueError(f"Vulnerability {vulnerability_data.vulnerability_id} already exists")
        
        # Create vulnerability
        vulnerability = Vulnerability(
            **vulnerability_data.dict(exclude={"affected_tools"})
        )
        
        # Add affected tools
        if vulnerability_data.affected_tools:
            tools = self.db.query(AITool).filter(
                AITool.name.in_(vulnerability_data.affected_tools)
            ).all()
            
            vulnerability.affected_tools = tools
        
        self.db.add(vulnerability)
        self.db.commit()
        self.db.refresh(vulnerability)
        
        # Broadcast update via WebSocket
        self._broadcast_vulnerability_update(vulnerability, "created")
        
        logger.info(f"Created vulnerability: {vulnerability.vulnerability_id}")
        return vulnerability
    
    def update_vulnerability(
        self, 
        vulnerability_id: str, 
        vulnerability_data: VulnerabilityUpdate
    ) -> Optional[Vulnerability]:
        """Update an existing vulnerability"""
        
        vulnerability = self.db.query(Vulnerability).filter(
            Vulnerability.vulnerability_id == vulnerability_id
        ).first()
        
        if not vulnerability:
            return None
        
        # Update fields
        for field, value in vulnerability_data.dict(exclude_unset=True).items():
            if hasattr(vulnerability, field):
                setattr(vulnerability, field, value)
        
        vulnerability.last_updated_timestamp = datetime.utcnow()
        
        self.db.commit()
        self.db.refresh(vulnerability)
        
        # Broadcast update via WebSocket
        self._broadcast_vulnerability_update(vulnerability, "updated")
        
        logger.info(f"Updated vulnerability: {vulnerability_id}")
        return vulnerability
    
    def get_vulnerability_by_id(self, vulnerability_id: str) -> Optional[Vulnerability]:
        """Get vulnerability by ID"""
        return self.db.query(Vulnerability).filter(
            Vulnerability.vulnerability_id == vulnerability_id
        ).first()
    
    def delete_vulnerability(self, vulnerability_id: str) -> bool:
        """Delete a vulnerability"""
        vulnerability = self.db.query(Vulnerability).filter(
            Vulnerability.vulnerability_id == vulnerability_id
        ).first()
        
        if not vulnerability:
            return False
        
        self.db.delete(vulnerability)
        self.db.commit()
        
        # Broadcast deletion via WebSocket
        self._broadcast_vulnerability_update(vulnerability, "deleted")
        
        logger.info(f"Deleted vulnerability: {vulnerability_id}")
        return True
    
    def add_tool_to_vulnerability(self, vulnerability_id: str, tool_name: str) -> bool:
        """Add an affected tool to a vulnerability"""
        vulnerability = self.get_vulnerability_by_id(vulnerability_id)
        if not vulnerability:
            return False
        
        tool = self.db.query(AITool).filter(AITool.name == tool_name).first()
        if not tool:
            return False
        
        if tool not in vulnerability.affected_tools:
            vulnerability.affected_tools.append(tool)
            vulnerability.last_updated_timestamp = datetime.utcnow()
            self.db.commit()
            
            # Broadcast update
            self._broadcast_vulnerability_update(vulnerability, "updated")
            
            logger.info(f"Added tool {tool_name} to vulnerability {vulnerability_id}")
        
        return True
    
    def remove_tool_from_vulnerability(self, vulnerability_id: str, tool_name: str) -> bool:
        """Remove an affected tool from a vulnerability"""
        vulnerability = self.get_vulnerability_by_id(vulnerability_id)
        if not vulnerability:
            return False
        
        tool = self.db.query(AITool).filter(AITool.name == tool_name).first()
        if not tool:
            return False
        
        if tool in vulnerability.affected_tools:
            vulnerability.affected_tools.remove(tool)
            vulnerability.last_updated_timestamp = datetime.utcnow()
            self.db.commit()
            
            # Broadcast update
            self._broadcast_vulnerability_update(vulnerability, "updated")
            
            logger.info(f"Removed tool {tool_name} from vulnerability {vulnerability_id}")
        
        return True
    
    def mark_vulnerability_patched(
        self, 
        vulnerability_id: str, 
        fixed_versions: dict = None
    ) -> bool:
        """Mark a vulnerability as patched"""
        vulnerability = self.get_vulnerability_by_id(vulnerability_id)
        if not vulnerability:
            return False
        
        from app.models.vulnerability import PatchStatusEnum
        vulnerability.patch_status = PatchStatusEnum.PATCHED
        
        if fixed_versions:
            vulnerability.fixed_versions = fixed_versions
        
        vulnerability.last_updated_timestamp = datetime.utcnow()
        self.db.commit()
        
        # Broadcast update
        self._broadcast_vulnerability_update(vulnerability, "patched")
        
        logger.info(f"Marked vulnerability {vulnerability_id} as patched")
        return True
    
    def get_critical_vulnerabilities(self, unpatched_only: bool = True) -> List[Vulnerability]:
        """Get critical vulnerabilities"""
        from app.models.vulnerability import SeverityEnum, PatchStatusEnum
        
        query = self.db.query(Vulnerability).filter(
            Vulnerability.severity == SeverityEnum.CRITICAL
        )
        
        if unpatched_only:
            query = query.filter(
                Vulnerability.patch_status == PatchStatusEnum.UNPATCHED
            )
        
        return query.order_by(Vulnerability.discovery_date.desc()).all()
    
    def get_vulnerabilities_by_tool(self, tool_name: str) -> List[Vulnerability]:
        """Get all vulnerabilities affecting a specific tool"""
        return self.db.query(Vulnerability).join(Vulnerability.affected_tools).filter(
            AITool.name == tool_name
        ).order_by(Vulnerability.discovery_date.desc()).all()
    
    async def _broadcast_vulnerability_update(self, vulnerability: Vulnerability, action: str):
        """Broadcast vulnerability update via WebSocket"""
        try:
            vulnerability_data = vulnerability.to_dict()
            vulnerability_data["action"] = action
            
            await websocket_manager.broadcast_vulnerability_update(vulnerability_data)
        except Exception as e:
            logger.error(f"Error broadcasting vulnerability update: {e}")